# dict(1) completion                                       -*- shell-script -*-

_dictdata()
{
    dict $host $port $1 2>/dev/null | sed -ne \
        's/^['$'\t '']['$'\t '']*\([^'$'\t '']*\).*$/\1/p'
}

_dict()
{
    local cur prev words cword
    _init_completion || return

    local host port db i

    for (( i=1; i < cword; i++ )); do
        case ${words[i]} in
            -h|--host)
                host=${words[i+1]}
                [[ -n $host ]] && host="-h $host"
                i=$((++i))
                ;;
            -p|--port)
                port=${words[i+1]}
                [[ -n $port ]] && port="-p $port"
                i=$((++i))
                ;;
            -d|--database)
                db=${words[i+1]}
                [[ -n $db ]] && host="-d $db"
                i=$((++i))
                ;;
            *)
                ;;
        esac
    done

    if [[ "$cur" = -* ]]; then
        COMPREPLY=( $( compgen -W '$( _parse_help "$1" )' -- "$cur" ) )
        return 0
    fi

    case $prev in
        -d|--database|-i|-info)
            COMPREPLY=( $( compgen -W '$( _dictdata -D )' -- "$cur" ) )
            return 0
            ;;
        -s|--strategy)
            COMPREPLY=( $( compgen -W '$( _dictdata -S )' -- "$cur" ) )
            return 0
            ;;
        *)
            ;;
    esac

    local dictfile=/usr/share/dict/words
    if [[ -r $dictfile ]]; then
        # Dictfile may be too large for practical compgen -W usage, so narrow
        # it down with grep if $cur looks like something that's safe to embed
        # in a pattern instead.
        if [[ $cur == +([-A-Za-z0-9/.]) ]]; then
            COMPREPLY=( $( compgen -W \
                '$( command grep "^${cur//./\\.}" $dictfile )' -- "$cur" ) )
        else
            COMPREPLY=( $( compgen -W '$( cat $dictfile )' -- "$cur" ) )
        fi
    fi
} &&
complete -F _dict -o default dict rdict

# ex: ts=4 sw=4 et filetype=sh

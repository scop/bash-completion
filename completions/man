# man(1) completion                                        -*- shell-script -*-

_man()
{
    local cur prev words cword split comp_args
    _comp_initialize -s -n : -- "$@" || return

    local comprsuffix=".@([glx]z|bz2|lzma|Z|zst)"
    local manext="@([0-9]*([a-z])|[lnp]|man)?($comprsuffix)"
    local mansect="@([0-9]*([a-z])|[lnp])"

    local noargopts='!(-*|*[ClMSsPpLmerRE]*)'
    # shellcheck disable=SC2254
    case $prev in
        --config-file | -${noargopts}C)
            _filedir conf
            return
            ;;
        --local-file | -${noargopts}l)
            _filedir "$manext"
            return
            ;;
        --manpath | -${noargopts}M)
            _filedir -d
            return
            ;;
        --sections | -${noargopts}[Ss])
            _comp_delimited : -W '{1..9}'
            return
            ;;
        --pager | -${noargopts}P)
            compopt -o filenames
            COMPREPLY=($(compgen -c -- "$cur"))
            return
            ;;
        --preprocessor | -${noargopts}p)
            COMPREPLY=($(compgen -W 'e p t g r v' -- "$cur"))
            return
            ;;
        --locale | --systems | --extension | --prompt | --recode | --encoding | \
            -${noargopts}[LmerRE])
            return
            ;;
    esac

    $split && return

    if [[ $cur == -* ]]; then
        COMPREPLY=($(
            compgen -W '$(_parse_help "$1" -h || _parse_usage "$1")' -- "$cur"
        ))
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace
        return
    fi

    # file based completion if parameter looks like a path
    if _comp_looks_like_path "$cur"; then
        _filedir "$manext"
        return
    fi

    local manpath=$(manpath 2>/dev/null || command man -w 2>/dev/null)
    if [[ ! $manpath ]]; then
        # Note: Both "manpath" and "man -w" may be unavailable, in
        # which case we determine the man paths based on the
        # environment variable MANPATH.
        manpath=:${MANPATH-}:
        # Note: An empty path (represented by two consecutive colons
        # or a preceding/trailing colon) represents the system man
        # paths.
        manpath=${manpath//::/':/usr/share/man:/usr/local/share/man:'}
        manpath=${manpath:1:-1}
    fi

    # determine manual section to search
    local sect
    # shellcheck disable=SC2053
    [[ $prev == $mansect ]] && sect=$prev || sect='*'

    _comp_split -F : manpath "$manpath"
    if ((${#manpath[@]})); then
        manpath=("${manpath[@]/%//*man$sect/$cur*}" "${manpath[@]/%//*cat$sect/$cur*}")
        local IFS=
        _comp_expand_glob COMPREPLY '${manpath[@]}'
        _comp_unlocal IFS

        if ((${#COMPREPLY[@]} != 0)); then
            # weed out directory path names and paths to man pages (empty
            # elements will be removed by the later `compgen -X ''`)
            COMPREPLY=("${COMPREPLY[@]##*/?(:)}")
            # strip suffix from man pages
            COMPREPLY=("${COMPREPLY[@]%$comprsuffix}")
            _comp_split -l COMPREPLY "$(compgen -W '"${COMPREPLY[@]%.*}"' -X '' -- "${cur//\\\\/}")"
        fi
    fi

    # shellcheck disable=SC2053
    if [[ $prev != $mansect ]]; then
        # File based completion for the rest, prepending ./ if needed
        # (man 1.6f needs that for man pages in current dir)
        local i start=${#COMPREPLY[@]}
        _filedir "$manext"
        for ((i = start; i < ${#COMPREPLY[@]}; i++)); do
            [[ ${COMPREPLY[i]} == */* ]] || COMPREPLY[i]=./${COMPREPLY[i]}
        done
    fi

    __ltrim_colon_completions "$cur"
} &&
    complete -F _man man apropos whatis

# ex: filetype=sh
